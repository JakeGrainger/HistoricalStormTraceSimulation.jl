var documenterSearchIndex = {"docs":
[{"location":"types/#Internal-Types","page":"Internal types","title":"Internal Types","text":"","category":"section"},{"location":"types/","page":"Internal types","title":"Internal types","text":"There are two important objects when thinking about trace rescaling. First is the storm trace, and second is its summary. We store the trace as a StormTrace and the summary as a Vector{Float64}. A history of storm traces and summaries is then stored as a StormHistory.","category":"page"},{"location":"types/#Storm-Traces","page":"Internal types","title":"Storm Traces","text":"","category":"section"},{"location":"types/","page":"Internal types","title":"Internal types","text":"The storm trace type contains both the time points (a range) and the values (a matrix).","category":"page"},{"location":"types/","page":"Internal types","title":"Internal types","text":"StormTrace","category":"page"},{"location":"types/#HistoricalStormTraceSimulation.StormTrace","page":"Internal types","title":"HistoricalStormTraceSimulation.StormTrace","text":"StormTrace(value,time)\n\nConstruct a StormTrace type used for storing a storm type.\n\nArguments\n\nvalue: A matrix of floats which is n × p.\ntime: An abstract range of length n.\n\n\n\n\n\n","category":"type"},{"location":"types/","page":"Internal types","title":"Internal types","text":"You can compute the number of variables using ","category":"page"},{"location":"types/","page":"Internal types","title":"Internal types","text":"nvariables","category":"page"},{"location":"types/#HistoricalStormTraceSimulation.nvariables","page":"Internal types","title":"HistoricalStormTraceSimulation.nvariables","text":"nvariables(t::StormTrace)\n\nCompute the number of variable contained by a storm trace, including time.\n\nThis is size(t.value,2)+1.\n\n\n\n\n\n","category":"function"},{"location":"types/","page":"Internal types","title":"Internal types","text":"You can compute the length (number of time points) with","category":"page"},{"location":"types/","page":"Internal types","title":"Internal types","text":"length(::StormTrace)","category":"page"},{"location":"types/#Base.length-Tuple{StormTrace}","page":"Internal types","title":"Base.length","text":"length(t::StormTrace)\n\nCompute the length of a StormTrace, which is the number of time points (not total number of elements).\n\n\n\n\n\n","category":"method"},{"location":"types/#Storm-History","page":"Internal types","title":"Storm History","text":"","category":"section"},{"location":"types/","page":"Internal types","title":"Internal types","text":"StormHistory","category":"page"},{"location":"types/#HistoricalStormTraceSimulation.StormHistory","page":"Internal types","title":"HistoricalStormTraceSimulation.StormHistory","text":"StormHistory(summaries,traces)\n\nFor storing historical storms.\n\nArguments\n\nsummaries: Should be a vector of vectors each of length q, containing summaries of storms.\ntraces: Should be a vector of StormTraces, each satisfying nvariables(t)==q.\n\n\n\n\n\n","category":"type"},{"location":"types/","page":"Internal types","title":"Internal types","text":"You can compute the number of storms with","category":"page"},{"location":"types/","page":"Internal types","title":"Internal types","text":"length(::StormHistory)","category":"page"},{"location":"types/#Base.length-Tuple{StormHistory}","page":"Internal types","title":"Base.length","text":"length(s::StormHistory)\n\nCompute the length of a StormHistory, i.e. the number of storms contained in the history.\n\n\n\n\n\n","category":"method"},{"location":"rescalemethods/#Rescale-Methods","page":"Rescale Methods","title":"Rescale Methods","text":"","category":"section"},{"location":"rescalemethods/","page":"Rescale Methods","title":"Rescale Methods","text":"Rescale methods define ways of rescaling a trace to match a summary. They are defined to be subtypes of RescaleMethod.","category":"page"},{"location":"rescalemethods/","page":"Rescale Methods","title":"Rescale Methods","text":"The rescale method itself is defined by extending rescalesinglevariable! for the new type. For example:","category":"page"},{"location":"rescalemethods/","page":"Rescale Methods","title":"Rescale Methods","text":"struct RescaleMaxChangeMin <: RescaleMethod end\nfunction rescalesinglevariable!(x::AbstractVector,y::Real,::RescaleMaxChangeMin)\n    rescale = y/maximum(x)\n    for i in eachindex(x)\n        @inbounds x[i] *= rescale\n    end\n    nothing\nend","category":"page"},{"location":"rescalemethods/","page":"Rescale Methods","title":"Rescale Methods","text":"is the implementation for RescaleMaxChangeMin.","category":"page"},{"location":"rescalemethods/","page":"Rescale Methods","title":"Rescale Methods","text":"The rescaletrace! function will call rescalesinglevariable! on each variable in a trace in turn, it takes a Tuple of RescaleMethods which allows for different rescales for different variables.","category":"page"},{"location":"rescalemethods/#Available-Methods","page":"Rescale Methods","title":"Available Methods","text":"","category":"section"},{"location":"rescalemethods/","page":"Rescale Methods","title":"Rescale Methods","text":"RescaleIdentity\nRescaleMaxChangeMin\nRescaleMaxPreserveMin\nRescaleMean\nRescaleMeanCircularDeg","category":"page"},{"location":"rescalemethods/#HistoricalStormTraceSimulation.RescaleIdentity","page":"Rescale Methods","title":"HistoricalStormTraceSimulation.RescaleIdentity","text":"RescaleIdentity()\n\nA rescale type to represent the identity rescale.\n\n\n\n\n\n","category":"type"},{"location":"rescalemethods/#HistoricalStormTraceSimulation.RescaleMaxChangeMin","page":"Rescale Methods","title":"HistoricalStormTraceSimulation.RescaleMaxChangeMin","text":"RescaleMaxChangeMin()\n\nLinear rescale to adjust the maximum of the new trace to equal the summary value.\n\nGiven a trace variable series y_j, and summary value x_j, the new trace  tildey_j is constructed using the following rule, forall tin T_y:\n\ntilde y_j(t) = fracx_jmaxlimits_tin T_yy_j(t)y_j(t)\n\n\n\n\n\n","category":"type"},{"location":"rescalemethods/#HistoricalStormTraceSimulation.RescaleMaxPreserveMin","page":"Rescale Methods","title":"HistoricalStormTraceSimulation.RescaleMaxPreserveMin","text":"RescaleMaxPreserveMin()\n\nLinear rescale to adjust the maximum of the new trace to equal the summary value whilst preserving the minimum. \n\nGiven a trace variable series y_j, and summary value x_j, the new trace  tildey_j is constructed using the following rule, forall tin T_y:\n\ntilde y_j(t) = fracx_j-minlimits_tin T_y  y_j(t)maxlimits_tin T_yy_j(t)-minlimits_tin T_y  y_j(t) left(y_j(t)-minlimits_tin T_y  y_j(t)right) + minlimits_tin T_y  y_j(t)\n\nThis only works if the new maximum x_j satisfies x_jminlimits_tin T_y  y_j(t). The formula is forall tin T_y. If this condition is not satisfied, a warning will be displayed.\n\n\n\n\n\n","category":"type"},{"location":"rescalemethods/#HistoricalStormTraceSimulation.RescaleMean","page":"Rescale Methods","title":"HistoricalStormTraceSimulation.RescaleMean","text":"RescaleMean()\n\nAdditive rescaling to match the mean of the trace to the summary value.\n\nGiven a trace variable series y_j, and summary value x_j, the new trace \n\ntilde y_j(t) = y_j(t) - overliney_j + x_j\n\nwhere overliney_j = frac1T_y sum_tin T_yy_j(t).\n\n\n\n\n\n","category":"type"},{"location":"rescalemethods/#HistoricalStormTraceSimulation.RescaleMeanCircularDeg","page":"Rescale Methods","title":"HistoricalStormTraceSimulation.RescaleMeanCircularDeg","text":"RescaleMeanCircularDeg()\n\nRescale the angular mean assuming data is in degrees.\n\nGiven a trace variable series y_j, and summary value x_j, the new trace \n\ntilde y_j(t) = y_j(t) - overliney_j + x_j\n\nwhere overliney_j = argleft(frac1T_y sum_tin T_yexpi y_j(t)right).\n\n\n\n\n\n","category":"type"},{"location":"tracescore/#Choosing-Summary-Metrics","page":"Choosing Summary Metrics","title":"Choosing Summary Metrics","text":"","category":"section"},{"location":"tracescore/","page":"Choosing Summary Metrics","title":"Choosing Summary Metrics","text":"The choice of distance measure in the storm summary space is not always obvious. One way to choose is to pick some parametric distance (e.g. weighted Euclidean distance) and then choose the parameters by try to optimise for the performance of the simulated traces.","category":"page"},{"location":"tracescore/","page":"Choosing Summary Metrics","title":"Choosing Summary Metrics","text":"If we have a score for the similarity of two traces, we can try to minimise the expected score of the simulated traces against the true historical traces.","category":"page"},{"location":"tracescore/","page":"Choosing Summary Metrics","title":"Choosing Summary Metrics","text":"To do this, use","category":"page"},{"location":"tracescore/","page":"Choosing Summary Metrics","title":"Choosing Summary Metrics","text":"find_best_distance\nexpected_score\nconditional_expected_score","category":"page"},{"location":"tracescore/#HistoricalStormTraceSimulation.find_best_distance","page":"Choosing Summary Metrics","title":"HistoricalStormTraceSimulation.find_best_distance","text":"find_best_distance(D::Type{<:Metric},x₀,history; lowerbounds, upperbounds, optim_kwargs=(), kwargs...)\n\nUse optim to find the best distance based on score_method scoring.\n\nArguments:\n\nD the type of distance (e.g. WeightedEuclidean). Note this is the constructor for the type, not an instance!\nx₀ initial parameters for the distance to start optimisation.\nhistory the storm history.\nlowerbounds the lower bounds for the optimisation, defaults to fill(-Inf,length(x₀)).\nupperbounds the upper bounds for the optimisation, defaults to fill(Inf,length(x₀)).\noptim_kwargs: Key word arguments to be passed to Optim.\nkwargs additional key word arguments, similar to score_method, but not including summarymetric, as this is specified by the optimisation.\n\nNote:\n\nTo use WeightedPeriodicEuclidean, you first need to select the periods p, and then create a constructor to fix these, e.g.\n\njulia> myperiods = [Inf,Inf,360.0]\n3-element Vector{Float64}:\n  Inf\n  Inf\n 360.0\n\njulia> myperiodicdistance(w) = WeightedPeriodicEuclidean(myperiods,w)\nmyperiodicdistance (generic function with 1 method)\n\nThen pass myperiodicdistance as the argument D to find_best_distance.\n\n\n\n\n\n","category":"function"},{"location":"tracescore/#HistoricalStormTraceSimulation.expected_score","page":"Choosing Summary Metrics","title":"HistoricalStormTraceSimulation.expected_score","text":"expected_score(history::StormHistory; samplemethod=1:50, rescalemethod, summarymetric::Metric=Euclidean(), interpolation_method=LinearInterpolation, tracescore::TraceScore)\n\nCompute the expected score.\n\nArguments:\n\nhistory, samplemethod, rescalemethod, summarymetric, interpolation_method: see sampletraces.\ntracescore: Score for comparing traces.\n\n\n\n\n\n","category":"function"},{"location":"tracescore/#HistoricalStormTraceSimulation.conditional_expected_score","page":"Choosing Summary Metrics","title":"HistoricalStormTraceSimulation.conditional_expected_score","text":"conditional_expected_score(summary,trace,history,sampler,rescalemethod,interpolation_method,tracescore)\n\nCompute the conditional expected score of a given historical trace. A different method will be used if the trace sampler uses a uniform over the closest m points method (i.e. if the sampler has a UnitRange for its samplemethod).\n\nArguments\n\nsummary: The summary of a historical trace.\ntrace: The corresponding trace.\nsampler: A TraceSampler.\nhistory, rescalemethod, interpolation_method: see sampletraces\ntracescore: Score for comparing traces.\n\n\n\n\n\n","category":"function"},{"location":"tracescore/#Trace-Scoring","page":"Choosing Summary Metrics","title":"Trace Scoring","text":"","category":"section"},{"location":"tracescore/","page":"Choosing Summary Metrics","title":"Choosing Summary Metrics","text":"Trace scores can be specified as a subtype of TraceScore. A functor should then be defined taking in two traces, which returns a measure of similarity between the two, with 0 being identical.","category":"page"},{"location":"tracescore/","page":"Choosing Summary Metrics","title":"Choosing Summary Metrics","text":"Provided is MarginalTraceScore which allows the user to define weighted sums of scores (usually metrics) applied to each variable.","category":"page"},{"location":"tracescore/","page":"Choosing Summary Metrics","title":"Choosing Summary Metrics","text":"MarginalTraceScore","category":"page"},{"location":"tracescore/#HistoricalStormTraceSimulation.MarginalTraceScore","page":"Choosing Summary Metrics","title":"HistoricalStormTraceSimulation.MarginalTraceScore","text":"MarginalTraceScore(metrics::NTuple{N,Metric},weights=ones(length(metrics)))\n\nConstruct a scoring method for traces based on a weighted some of marginal metrics.\n\nArguments\n\nmetrics: Should be a tuple of p metrics, where p is the number of variables in the trace of interest (not including time).\nweights: A vector of weights to be used (defaults to vector of ones).\n\nUse\n\nGiven a MarginalTraceScore called mscore.\n\n(mscore::MarginalTraceScore)(t1::StormTrace,t2::StormTrace)\n\nwill compute the marginal trace score between two traces t1 and t2.\n\n\n\n\n\n","category":"type"},{"location":"tracescore/","page":"Choosing Summary Metrics","title":"Choosing Summary Metrics","text":"Convenience functions for checking compatibility are also provided:","category":"page"},{"location":"tracescore/","page":"Choosing Summary Metrics","title":"Choosing Summary Metrics","text":"HistoricalStormTraceSimulation.checkcompatible","category":"page"},{"location":"tracescore/#HistoricalStormTraceSimulation.checkcompatible","page":"Choosing Summary Metrics","title":"HistoricalStormTraceSimulation.checkcompatible","text":"checkcompatible(m::MarginalTraceScore,t::StormTrace)\n\nCheck trace is compatible with MarginalTraceScore.\n\n\n\n\n\ncheckcompatible(t1::StormTrace,t2::StormTrace)\n\nCheck two traces are compatible.\n\n\n\n\n\n","category":"function"},{"location":"tracescore/#Implementing-new-trace-scores","page":"Choosing Summary Metrics","title":"Implementing new trace scores","text":"","category":"section"},{"location":"tracescore/","page":"Choosing Summary Metrics","title":"Choosing Summary Metrics","text":"New methods can be implemented by analogy to the implementation for MarginalTraceScore:","category":"page"},{"location":"tracescore/","page":"Choosing Summary Metrics","title":"Choosing Summary Metrics","text":"struct MarginalTraceScore{T,S} <: TraceScore\n    metrics::T\n    weights::S\n    function MarginalTraceScore(metrics::NTuple{N,Metric},weights=ones(length(metrics))) where {N}\n        length(metrics) == length(weights) || throw(DimensionMismatch(\"weights and metrics should be same length.\"))\n        new{typeof(metrics),typeof(weights)}(metrics,weights)\n    end\nend\n\nfunction (mscore::MarginalTraceScore)(t1::StormTrace,t2::StormTrace)\n    checkcompatible(t1,t2)\n    checkcompatible(mscore,t1)\n    score = 0.0\n    for i in eachindex(mscore.metrics)\n        @views score += mscore.weights[i]*mscore.metrics[i](t1.value[:,i],t2.value[:,i])\n    end\n    return score\nend","category":"page"},{"location":"tracescore/#Periodic-trace-scores","page":"Choosing Summary Metrics","title":"Periodic trace scores","text":"","category":"section"},{"location":"tracescore/","page":"Choosing Summary Metrics","title":"Choosing Summary Metrics","text":"If one of the marginal traces should be periodic, use the following metric as opposed to PeriodicEuclidean, as that will only work for arrays of a fixed size.","category":"page"},{"location":"tracescore/","page":"Choosing Summary Metrics","title":"Choosing Summary Metrics","text":"SinglePeriodicEuclidean","category":"page"},{"location":"tracescore/#HistoricalStormTraceSimulation.SinglePeriodicEuclidean","page":"Choosing Summary Metrics","title":"HistoricalStormTraceSimulation.SinglePeriodicEuclidean","text":"SinglePeriodicEuclidean(p)\n\nCreate a weighted Euclidean metric on a rectangular periodic domain where all dimensions have the same period.\n\nBased on the PeriodicEuclidean from Distances.jl. The provided period p should be scalar.\n\n\n\n\n\n","category":"type"},{"location":"basics/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"basics/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"basics/","page":"Getting Started","title":"Getting Started","text":"The package can be installed from the repl using","category":"page"},{"location":"basics/","page":"Getting Started","title":"Getting Started","text":"(v1.7) pkg> add https://github.com/JakeGrainger/HistoricalStormTraceSimulation.jl","category":"page"},{"location":"basics/","page":"Getting Started","title":"Getting Started","text":"There are two main interface functions which should be used:","category":"page"},{"location":"basics/#Sample-Traces","page":"Getting Started","title":"Sample Traces","text":"","category":"section"},{"location":"basics/","page":"Getting Started","title":"Getting Started","text":"sampletraces","category":"page"},{"location":"basics/#HistoricalStormTraceSimulation.sampletraces","page":"Getting Started","title":"HistoricalStormTraceSimulation.sampletraces","text":"sampletraces(new_summaries, historical_summaries, historical_traces; samplemethod=1:50, rescalemethod)\n\nSample new traces given summaries based on modifications of historical traces.\n\nArguments\n\nnew_summaries: Vector of summaries to generate traces for.\nhistory: Storm history information of type StormHistory. Best constructed using dataframes2storms function.\nsamplemethod: Method for sampling from closest points. Passing 1:m will sample uniformly from the closest m points. Defaults to 1:50. Could also be a Distribution. Note that if a Distribution is used, then it should be discrete, and should be defined on 1:n where n is the number of historical storms.\nrescalemethod: Tuple of methods for rescaling (one for each column of the trace). Should be a subtype of type RescaleMethod.\nsummarymetric: A metric for determining closeness of storm summaries (must be subtype of Metric). Default is Euclidean(). Note care should be taken when dealing with directions, in this case, use PeriodicEuclidean or WeightedPeriodicEuclidean with the appropriate period choices.\ninterpolation_method: Method for performing interpolation. LinearInterpolation is the default, but CubicSplineInterpolation may be preferable in some contexts (though it is much slower).\n\nRescaleMethods\n\nRescaleIdentity(): The identity (no rescale).\nRescaleMean(): Rescale the mean to match provided mean.\nRescaleMaxChangeMin(): Rescale the maximum to match provided maximum, using linear scaling and changing the minimum.\nRescaleMaxPreserveMin(): Rescale the maximum to match provided maximum, using linear scaling but preserving the minimum\n\n\n\n\n\n","category":"function"},{"location":"basics/","page":"Getting Started","title":"Getting Started","text":"This is the main function used to generate traces from historical storms. This package provides an additional metric for periodic Weighted Euclidean distance:","category":"page"},{"location":"basics/","page":"Getting Started","title":"Getting Started","text":"WeightedPeriodicEuclidean","category":"page"},{"location":"basics/#HistoricalStormTraceSimulation.WeightedPeriodicEuclidean","page":"Getting Started","title":"HistoricalStormTraceSimulation.WeightedPeriodicEuclidean","text":"WeightedPeriodicEuclidean(p,w)\n\nCreate a weighted Euclidean metric on a rectangular periodic domain (i.e., a torus or a cylinder). Periods per dimension are contained in the vector p, and weights in w:\n\nsqrtsum_i w_i*(minmod(x_i - y_i p_i) p_i - mod(x_i - y_i p_i))^2\n\nBased on the PeriodicEuclidean from Distances.jl.\n\n\n\n\n\n","category":"type"},{"location":"basics/#Converting-Data-to-Internal-Types","page":"Getting Started","title":"Converting Data to Internal Types","text":"","category":"section"},{"location":"basics/","page":"Getting Started","title":"Getting Started","text":"This package uses its own types to conveniently represent the concepts it deals with. In particular, types for representing storm traces and summaries. Data of this kind usually comes from outputs of other software, which usually is in the form of named data frames. The dataframes2storms function converts such data frames to the correct format for the package.","category":"page"},{"location":"basics/","page":"Getting Started","title":"Getting Started","text":"dataframes2storms","category":"page"},{"location":"basics/#HistoricalStormTraceSimulation.dataframes2storms","page":"Getting Started","title":"HistoricalStormTraceSimulation.dataframes2storms","text":"dataframes2storms(event_data, event_start_end, input_data, simulated_data)\n\nConvert dataframes containing storm parameters and data to traces and summaries for use in package.\n\nWill reorder variables to match up names of variables. Pass outputs to sampletraces function.\n\nArguments:\n\nevent_data - DataFrame containing summaries of historical storms.\nevent_start_end - DataFrame containing start and end indices of events in input_data.\ninput_data - DataFrame containing historical time series.\nsimulated_data - DataFrame containing simulated storm summaries.\n\nOutputs:\n\nnew_summaries - Vector of summary vectors.\nhistory - StormHistory object.\nsummary_names - Names of summary variables in order (traces are the same but one less variable (time is separate)).\n\n\n\n\n\n","category":"function"},{"location":"basics/","page":"Getting Started","title":"Getting Started","text":"The arguments event_data and simulated data are the storm summaries, input_data is the complete time series (including the non-extreme time periods), and event_start_end is a data frame with column 1 containing the start index for a storm, and column 2 containing the end index. Note that this should be 1-indexed, not 0-indexed!","category":"page"},{"location":"basics/","page":"Getting Started","title":"Getting Started","text":"Note that it is important that naming conventions are consistent across data frames for this function to work.","category":"page"},{"location":"sampling/#Trace-Sampling","page":"Trace Sampling","title":"Trace Sampling","text":"","category":"section"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"Trace sampling performs the following steps:","category":"page"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"Draw a trace from the historical traces conditional on the summary.\nRescale the time to match the duration specified by the summary.\nInterpolate the trace back to the original time resolution.\nRescale the trace based on the rescale rules.","category":"page"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"Use samplesingletrace to perform this process for one trace.","category":"page"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"HistoricalStormTraceSimulation.samplesingletrace","category":"page"},{"location":"sampling/#HistoricalStormTraceSimulation.samplesingletrace","page":"Trace Sampling","title":"HistoricalStormTraceSimulation.samplesingletrace","text":"samplesingletrace(summary,history,sampler,rescalemethod,interpolation_method=LinearInterpolation)\n\nFunction to sample a trace given a summary and history.\n\nArguments\n\nsummary: The summary to simulate a trace for.\nhistory: The StormHistory to match to.\nsampler: Sampler of type TraceSampler.\nrescalemethod: see docstring for sampletraces.\ninterpolation_method: see docstring for sampletraces.\n\n\n\n\n\n","category":"function"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"Sometimes, it is useful to fix which trace is chosen in step 1. Use samplesinglefixedtrace to do this.","category":"page"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"HistoricalStormTraceSimulation.samplesinglefixedtrace","category":"page"},{"location":"sampling/#HistoricalStormTraceSimulation.samplesinglefixedtrace","page":"Trace Sampling","title":"HistoricalStormTraceSimulation.samplesinglefixedtrace","text":"samplesinglefixedtrace()\n\nMethod to simulate a fixed trace based on rescaling the ith historical trace.\n\n\n\n\n\n","category":"function"},{"location":"sampling/#Sampling-from-the-historical-traces","page":"Trace Sampling","title":"Sampling from the historical traces","text":"","category":"section"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"The sampling depends on the chosen distribution and the chosen distance used to measure the similarity between summaries.","category":"page"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"HistoricalStormTraceSimulation.samplehistoricaltrace","category":"page"},{"location":"sampling/#HistoricalStormTraceSimulation.samplehistoricaltrace","page":"Trace Sampling","title":"HistoricalStormTraceSimulation.samplehistoricaltrace","text":"samplehistoricaltrace(summary,history,sampler::TraceSampler)\n\nSample a historical trace from a history given a summary.\n\nSee samplesingletrace for argument details.\n\n\n\n\n\n","category":"function"},{"location":"sampling/#Trace-samplers","page":"Trace Sampling","title":"Trace samplers","text":"","category":"section"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"The method for trace sampling is specified by a TraceSampler.","category":"page"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"HistoricalStormTraceSimulation.TraceSampler\nHistoricalStormTraceSimulation.computedistances!","category":"page"},{"location":"sampling/#HistoricalStormTraceSimulation.TraceSampler","page":"Trace Sampling","title":"HistoricalStormTraceSimulation.TraceSampler","text":"TraceSampler(d,samplemethod,n::Int)\n\nArguments\n\nsummarymetric: A metric for determining closeness of storm summaries (must be subtype of Metric). Default is Euclidean().\nsamplemethod: Method for sampling from closest points. Passing 1:m will sample uniformly from the closest m points. Defaults to 1:50. Could also be a Distribution.\nn: The number of storms.\n\nNote\n\nThere is an alternate constructor      TraceSampler(summarymetric,samplemethod,distance_store,distance_index) this is an internal feature, distance_store and distance_index are constructed based on n in the other constructor. Their purpose is to preallocate distance storage and improve performance.\n\n\n\n\n\n","category":"type"},{"location":"sampling/#HistoricalStormTraceSimulation.computedistances!","page":"Trace Sampling","title":"HistoricalStormTraceSimulation.computedistances!","text":"computedistances!(summary,history,sampler::TraceSampler)\n\nCompute the distances for a given summary to all historical summaries.\n\nNote: This overwrites memory in sampler and returns nothing. See samplesingletrace for argument details.\n\n\n\n\n\n","category":"function"},{"location":"sampling/#Rescaling-time","page":"Trace Sampling","title":"Rescaling time","text":"","category":"section"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"Time rescaling of a trace can be done with adjusttracetime, which in turn calls rescaletime and then repacks as a StormTrace.","category":"page"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"HistoricalStormTraceSimulation.adjusttracetime\nHistoricalStormTraceSimulation.rescaletime","category":"page"},{"location":"sampling/#HistoricalStormTraceSimulation.adjusttracetime","page":"Trace Sampling","title":"HistoricalStormTraceSimulation.adjusttracetime","text":"adjusttracetime(trace, summary)\n\nAdjust the time of a trace based on a summary (just calls rescaletime and then repacks in a StormTrace).\n\n\n\n\n\n","category":"function"},{"location":"sampling/#HistoricalStormTraceSimulation.rescaletime","page":"Trace Sampling","title":"HistoricalStormTraceSimulation.rescaletime","text":"rescaletime(time,duration)\n\nRescale the time to match the duration (d) and start at 0. The formula is, forall t in T_y\n\ntildet_t = (t-min T_y) fracdmax T_y - min T_y\n\nThen the time vector of tilde y is T_tildey = tildet_t mid t in T_y.\n\n\n\n\n\n","category":"function"},{"location":"sampling/#Interpolating-the-trace","page":"Trace Sampling","title":"Interpolating the trace","text":"","category":"section"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"Interpolation is performed with","category":"page"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"HistoricalStormTraceSimulation.interpolatetrace","category":"page"},{"location":"sampling/#HistoricalStormTraceSimulation.interpolatetrace","page":"Trace Sampling","title":"HistoricalStormTraceSimulation.interpolatetrace","text":"interpolatetrace(trace,Δ,interpolation_method=LinearInterpolation)\n\nInterpolate a trace to a new resolution Δ.\n\nArguments\n\ntrace: The trace to be interpolated.\nΔ: The new time resolution.\ninterpolation_method: see docstring for sampletraces.\n\n\n\n\n\n","category":"function"},{"location":"sampling/#Rescaling-the-trace","page":"Trace Sampling","title":"Rescaling the trace","text":"","category":"section"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"Trace rescaling is performed by","category":"page"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"HistoricalStormTraceSimulation.rescaletrace!","category":"page"},{"location":"sampling/#HistoricalStormTraceSimulation.rescaletrace!","page":"Trace Sampling","title":"HistoricalStormTraceSimulation.rescaletrace!","text":"rescaletrace!(trace::StormTrace,summary,rescalemethod::NTuple{N,RescaleMethod}) where {N}\n\nRescale a trace to match a summary.\n\nArguments\n\ntrace: The StormTrace to be adjusted.\nsummary: The summary to simulate a trace for.\nrescalemethod: see docstring for sampletraces.\n\n\n\n\n\n","category":"function"},{"location":"sampling/","page":"Trace Sampling","title":"Trace Sampling","text":"See Rescale methods for details of the available rescale methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = HistoricalStormTraceSimulation","category":"page"},{"location":"#HistoricalStormTraceSimulation","page":"Home","title":"HistoricalStormTraceSimulation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for HistoricalStormTraceSimulation. A Julia package for simulating storm traces based on historical trace matching. See getting started for an introduction, or see the index for a list of functions and types.","category":"page"},{"location":"docstrings/","page":"Index","title":"Index","text":"","category":"page"}]
}
